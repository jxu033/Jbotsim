package jbotsim;


import java.awt.Color;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;


public abstract class Robot extends Node {
   
	
	SnapShot snap=null;
	Destination dest=null;
	boolean moving=false;
	boolean collided = false;
	boolean rigidMove = true; 
	boolean centerSensing = false; //Only the center of robot can sense its neighbors rather than the whole volue
	double minDistance =0;
	double[][] agreement = new double[2][2];
	double[][] localCoords = new double[1][1];
	
	Volume volume=null;
     
	int bounds = 0;
	int light = 0; // numbers represent different color
	int faultyRound = 0; 

	ArrayList<Robot> sensedRobots = null;


	public abstract SnapShot look();
	public abstract Destination compute(SnapShot snap);
	public abstract void move(Destination a);

	/**
	 * In the current topology
	 * @return all the robots at the same location as this robot, exclude this robot
	 */
	public List<Robot> getRobotsOntheSameLocation()
	{
		List<Robot> robots = new ArrayList<Robot>();
		for(Robot robot : topo.robots)
		{
			if(robot !=this)
			{
			  if(robot.getLocation().equals( this.getLocation()))
				  robots.add(robot);
			}
		}
		return robots;	
	}

	/**
	 * 
	 * @return a point around one Of Visible vertexes
	 */
	public Point2D goToPointAroundVisibleVertexes()
	{
		int size = this.snap.visVertexesOfObstacles.size();
		Point2D vertex = this.snap.visVertexesOfObstacles.get((int)(Math.random()*size));
		double newDest_x = (int)(vertex.getX() + (Math.random()*40-20) );
		double newDest_y = (int)(vertex.getY() + (Math.random()*40-20) );
		Point2D newDest = new Point2D.Double(newDest_x, newDest_y);
		return newDest;
	}
	
	 /**
	  * 
	  * @return get all the visible vertexes of obstacles in topology
	  */
	public List<Point2D> getVisibleVertexesOfObstacles()
	{
		List<Point2D> visibleVertexes = new ArrayList<Point2D>();
		List<Segment> visibleSegments = this.getVisibleSegments();
		if(visibleSegments.isEmpty()) 
			return visibleVertexes;
		for(Obstacle o : topo.obstacles)
			for(Point2D p : o.vertexesOfObstacle)
			{
				for(Segment s: visibleSegments)
				{
					if(p.equals(s.left)||p.equals(s.right))
					{						
						if(!visibleVertexes.contains(p))
						visibleVertexes.add(p);
					}
				}
			}
		return visibleVertexes;
	}
	
	
	
	/**
	 * Given a segment
	 * @return visible part of this segment in obstacle environment
	 */
	public int call_num=0;
	public List<Segment> getVisibleSegment(Segment segment)
	{
	 //	System.out.println(call_num+"called function"+segment);
		call_num++;
		if(call_num > 20)
		{
			System.exit(0);
		}
		
		
	   List<Segment> results = new ArrayList<Segment>();
	   Segment presentVisSeg = segment;
	   Segment intermediate;
	   Point2D visPoint;
	   for(Obstacle o: this.topo.obstacles)
	   {
		   for(Segment s : o.segmentsOfObstalce)
		   {
			   if(s.isPointOnSegment(presentVisSeg.left) && s.isPointOnSegment(presentVisSeg.right))
				   continue;
			   
			   Segment r_left = new Segment(this.getLocation(),presentVisSeg.left);
			   Segment r_right= new Segment(this.getLocation(),presentVisSeg.right);
			   
			   //used for seeing if a point is inside the polygon which is generated by segment, r_left, r_right
			   double[] xpoints = {presentVisSeg.left.getX(),presentVisSeg.right.getX(), this.getLocation().getX()};
			   double[] ypoints = {presentVisSeg.left.getY(),presentVisSeg.right.getY(), this.getLocation().getY()};
			   Polygon2D polygon2d = new Polygon2D(xpoints, ypoints, xpoints.length);		
			   
			   if(r_left.HasIntersectionWithSegment(s)
						&&r_right.HasIntersectionWithSegment(s))//case 1: segment is blocked entirely by segment s
			   return results;
			   
			   if(r_left.HasIntersectionWithSegment(s)==true && r_right.HasIntersectionWithSegment(s) == false) //case 2.
			   {
				   if(r_left.AreInSameLine(s))//add on date 3.29
					   continue;

				  Point2D intersection = r_left.intersectionWithSegment(s); 
				  
				   //step 1 : check which point of s is contained in the polygon above
				  if(!intersection.equals(s.left)  && !intersection.equals(s.right)   ) // scenario 1 
				  {
					 if(polygon2d.IsPointContained(s.left))
					 {
				   //step 2 : get a new segment between two points below
					  intermediate = new Segment(this.getLocation(), s.left);
				   //step 3 : get the intersection point of new segment and segment s
					   visPoint = intermediate.intersectionWithSegmentAsLine(presentVisSeg);
				   //step 4 : get the new visible segment that this robot can see at present
					  presentVisSeg = new Segment(visPoint, presentVisSeg.right);
				   //step 5 : continue checking if next s block this present visible segment 
					  continue;
					 }
					 else if (polygon2d.IsPointContained(s.right))
					 {
						  intermediate = new Segment(this.getLocation(), s.right);
					      visPoint = intermediate.intersectionWithSegmentAsLine(presentVisSeg);
					      presentVisSeg = new Segment(visPoint, presentVisSeg.right);		     
						  continue;
					 }
				  }
				  else if (polygon2d.IsPointContained(s.left) || polygon2d.IsPointContained(s.right))
				  { //scenario 2
					  if(intersection.equals(s.left))
					  {
					//step 2 : get a new segment between two points below
					  intermediate = new Segment(this.getLocation(), s.right);
				   //step 3 : get the intersection point of new segment and segment s
					   visPoint = intermediate.intersectionWithSegmentAsLine(presentVisSeg);
				   //step 4 : get the new visible segment that this robot can see at present
					  presentVisSeg = new Segment(visPoint, presentVisSeg.right);
				   //step 5 : continue checking if next s block this present visible segment 
					  continue;
					  }
					  else if (intersection.equals(s.right))
					  {
						  intermediate = new Segment(this.getLocation(), s.left);
					      visPoint = intermediate.intersectionWithSegmentAsLine(presentVisSeg);
					      presentVisSeg = new Segment(visPoint, presentVisSeg.right);
						  continue;
					  }				  
				  } 
				  // for scenario 3 the presentVisSeg is unchanged		  				  
			   }
			   
			   if(r_left.HasIntersectionWithSegment(s)==false && r_right.HasIntersectionWithSegment(s)==true) 
			   {//case 3		
				   
				   if(r_right.AreInSameLine(s))//add on date 3.29
					   continue;
				   
				   Point2D intersection = r_right.intersectionWithSegment(s); 
				   //step 1 : check which point of s is contained in the polygon above
				  if(!intersection.equals(s.left ) && !intersection.equals(s.right)  ) // scenario 1 
				  {
					 if(polygon2d.IsPointContained(s.left))
					 {
					  intermediate = new Segment(this.getLocation(), s.left);
					  visPoint = intermediate.intersectionWithSegmentAsLine(presentVisSeg);
					  presentVisSeg = new Segment(visPoint, presentVisSeg.left);
					  continue;
					 }
					 else if (polygon2d.IsPointContained(s.right))
					 {
						  intermediate = new Segment(this.getLocation(), s.right);
					      visPoint = intermediate.intersectionWithSegmentAsLine(presentVisSeg);
					      presentVisSeg = new Segment(visPoint, presentVisSeg.left);
						  continue;
					 }
				  }
				  else if (polygon2d.IsPointContained(s.left) || polygon2d.IsPointContained(s.right))
				  { //scenario 2
					  if(intersection.equals(s.left))
					  {
					//step 2 : get a new segment between two points below
					  intermediate = new Segment(this.getLocation(), s.right);
				   //step 3 : get the intersection point of new segment and segment s
					   visPoint = intermediate.intersectionWithSegmentAsLine(presentVisSeg);
				   //step 4 : get the new visible segment that this robot can see at present
					  presentVisSeg = new Segment(visPoint, presentVisSeg.left);
					
				   //step 5 : continue checking if next s block this present visible segment 
					  continue;
					  }
					  else if (intersection.equals(s.right))
					  {
						  intermediate = new Segment(this.getLocation(), s.left);
					      visPoint = intermediate.intersectionWithSegmentAsLine(presentVisSeg);
					      presentVisSeg = new Segment(visPoint, presentVisSeg.left);				    
						  continue;
					  }				  
				  } 
				  // for scenario 3 the presentVisSeg is unchanged		  		
			   }		   
			   
			   if(r_left.HasIntersectionWithSegment(s)==false && r_right.HasIntersectionWithSegment(s)==false
					   && polygon2d.IsPointContained(s.left) && polygon2d.IsPointContained(s.right))
				   //case 4
			   {
				   Segment intermediate1 = new Segment(this.getLocation(), s.left);
				   Segment intermediate2 = new Segment(this.getLocation(), s.right);
				   Point2D intersection1 = intermediate1.intersectionWithSegmentAsLine(presentVisSeg);
				   Point2D intersection2 = intermediate2.intersectionWithSegmentAsLine(presentVisSeg);
				 /*  if(intersection1.equals(intersection2))
				   {
					   continue;
				   }*/
				   Segment preVisSegment1;
				   Segment previsSegment2;
				   if(intersection1.distance(presentVisSeg.left) <= intersection2.distance(presentVisSeg.left))
				   {
					   preVisSegment1 = new Segment(intersection1, presentVisSeg.left);
					   previsSegment2 = new Segment(intersection2, presentVisSeg.right);
				   }
				   else {
					   preVisSegment1 = new Segment(intersection1, presentVisSeg.right);
					   previsSegment2 = new Segment(intersection2, presentVisSeg.left);
				}
				   List<Segment> part1 = getVisibleSegment(preVisSegment1);
				   List<Segment> part2 = getVisibleSegment(previsSegment2);
				   
				   if(!part1.isEmpty())
				   {
				    for(Segment x: part1)
				    {
				    	results.add(x);
				    }
				   }
				  
				   if(!part2.isEmpty())
				   {
				    for(Segment y : part2)
				    {
				    	results.add(y);
				    }
				   }
				    return results;		 	
			   }
		   }		   
	   }
	   
	   results.add(presentVisSeg);
		
	   return results;
	}
	
	
	/**
	 * Created by Jiaqi Xu
	 * @return all the visible segments in obstacles
	 */
	public List<Segment> getVisibleSegments()
	{ 
		List<Segment> visibleSegments = new ArrayList<Segment>();
		for(Obstacle o : this.topo.obstacles)
			for(Segment s: o.segmentsOfObstalce)//for each segment
			{
				call_num=0;
				List<Segment> visPart = getVisibleSegment(s);
				if(!visPart.isEmpty())
				{
					for(Segment segment : visPart)
					{
						visibleSegments.add(segment);
					}
				}
			}
		
		return visibleSegments;
	}
	
	// Created by Jiaqi Xu
	// return all the robots that this robot can see in the obstacle environment
	// in this topology
	public List<Robot> getVisibleRobots() {
		List<Robot> robots = new ArrayList<Robot>();
		boolean sign = false;
		double distance;

		for (Robot r : topo.robots) {
			if (r != this) {
				for (Obstacle o : this.topo.obstacles) {
					Segment segment = new Segment(this.getLocation(),r.getLocation());
					sign = o.intersectsWithSegment(segment);
					if (sign == true)
						break;
				}

				if (sign == false) {
					// ToFix
					distance = Math.sqrt((this.coords.getX() - r.coords.getX())
							* (this.coords.getX() - r.coords.getX())
							+ (this.coords.getY() - r.coords.getY())
							* (this.coords.getY() - r.coords.getY()));
					if (this.sensingRange >= distance) {
						robots.add(r);
					}
				}
			}
		}

		return robots;
	}
	
	@Override
	public void onPreClock() {
		super.onPreClock();
		snap=this.look();
	}

	@Override
	public void onClock() {
		super.onClock();
		dest=this.compute(snap);
		this.moving=true;
	}

	@Override
	public void onPostClock() {
		super.onPostClock();
		this.move(dest);
	}

	public double distance(Destination dest){
		double dist=0;
		if(dest instanceof Destination2D){
			dist=this.distance(((Destination2D)dest).dest);

		}
		return dist;
	}

	 public void notRigidMove() {
		    double scale = Math.random();

		    double x = scale * (((Destination2D) this.dest).dest.getX() - this.getX());
		    double y = scale * (((Destination2D) this.dest).dest.getY() - this.getY());

		    Destination2D newDest;
		    newDest = new Destination2D();
		    newDest.dest = new Point2D.Double();
		    newDest.dest.setLocation(this.getX() + x, this.getY() + y);

		    Destination olddest = this.dest;
		    if (this.minDistance < this.distance(newDest)
		            && this.distance(olddest) > this.distance(newDest)) {
		        this.dest = newDest;
		        this.onPostClock();
		    } else {
		        this.setDirection(((Destination2D) dest).dest);
		        move(this.minDistance);
		    }
		    this.dest = olddest;
		}

		public void asynchMove() {
		    System.out.println("AsyncMove on" +this.getID());
		    this.moving = true;
		    Random rd = new Random();
		    
		    	System.out.println("amove"+this.dest);
		    if (rd.nextBoolean() == false) {
		        double scale = Math.random();

		        double x = scale * (((Destination2D) dest).dest.getX() - this.getX());
		        double y = scale * (((Destination2D) dest).dest.getY() - this.getY());

		        Destination2D newDest;
		        newDest = new Destination2D();
		        newDest.dest = new Point2D.Double();
		        newDest.dest.setLocation(this.getX() + x, this.getY() + y);

		        Destination olddest = this.dest;
		        this.dest = newDest;
		        this.onPostClock();
		        this.dest = olddest;

		    } else {

		        this.moving = false;
		        this.onPostClock();
		    }
		   }

	//get sensed robots within the sensing range
	public ArrayList<Robot> getSensedRobots(){
		ArrayList<Robot> robots = new ArrayList<>();
		for (Node node : this.getSensedNodes()){
			if(node instanceof Robot)
			robots.add((Robot)node);
		}
		sensedRobots = robots;
		return robots;
	}
	
	public boolean mayCollide(Robot robot) {
	    Point2D dest1 = ((Destination2D) this.dest).dest;
	    Point2D dest2 = ((Destination2D) robot.dest).dest;
	    Line2D line1 = new Line2D.Double(this.getLocation(), dest1);
	    Line2D line2 = new Line2D.Double(robot.getLocation(), dest2);

	    if (line1.getY2() == line1.getY1()
	            && line1.getX1() == line1.getX2()
	            && line2.getY2() == line2.getY1()
	            && line2.getX1() == line2.getX2()) {
	        return false;
	    }

	    if (dest1.equals(dest2) || Line2D.linesIntersect(this.getX(), this.getY(), dest1.getX(), dest1.getY(),
	                    robot.getX(), robot.getY(), dest2.getX(), dest2.getY())) {
	        return true;
	    } else if (this.volume != null && robot.volume != null) {
	        if (line1.ptSegDist(dest2) < (this.volume.getRadius() + robot.volume.getRadius())
	                || line2.ptSegDist(dest1) < (this.volume.getRadius() + robot.volume.getRadius())) {
	            return true;
	        }
	    }
	    return false;
	}
	
	private void setSnapAgreement() {

	    ArrayList<Robot> r = new ArrayList<>();
	    for (Robot robot : this.snap.getRobots()) {
	        Robot temp = (Robot) robot.clone();
	        Point2D p = getInMyCoords(robot.getLocation());
	        temp.setLocation(p.getX(), p.getY());
	        r.add(temp);

	    }
	    this.snap.setRobots(r);

	}

	public void setRandomAgreement() {
	    double[][] agreement = new double[2][2];
	    double angle = 2 * Math.PI * Math.random();
	    agreement[0][0] = Math.cos(angle);
	    agreement[0][1] = -1 * Math.sin(angle);
	    agreement[1][0] = Math.sin(angle);
	    agreement[1][1] = Math.cos(angle);
	    this.agreement = agreement;
	    this.setLocalCoords();
	    this.setSnapAgreement();
	}

	public Point2D getInMyCoords(Point2D point2D) {
	    Point2D result = new Point2D.Double();

	    double x = this.agreement[0][0] * point2D.getX() + this.agreement[0][1] * point2D.getY();
	    double y = this.agreement[1][0] * point2D.getX() + this.agreement[1][1] * point2D.getY();

	    result.setLocation(x, y);
	    return result;
	}

	public Point2D getFromMyCoords(Point2D point2D) {

	    Point2D result = new Point2D.Double();
	    double determinant = this.agreement[0][0] * this.agreement[1][1] - this.agreement[0][1] * this.agreement[1][0];
	    double[][] transp = new double[2][2];
	    transp[0][0] = this.agreement[1][1] * 1 / determinant;
	    transp[1][1] = this.agreement[0][0] * 1 / determinant;

	    transp[0][1] = -this.agreement[0][1] * 1 / determinant;
	    transp[1][0] = -this.agreement[1][0] * 1 / determinant;

	    double x = transp[0][0] * point2D.getX() + transp[0][1] * point2D.getY();
	    double y = transp[1][0] * point2D.getX() + transp[1][1] * point2D.getY();

	    result.setLocation(x, y);
	    return result;
	}

	public void setLocalCoords() {
	    double[][] coords = new double[1][1];
	    coords[0][0] = this.agreement[0][0] * this.getX() + this.agreement[0][1] * this.getY();
	    //coords[1][0] = this.agreement[1][0] * this.getX() + this.agreement[1][1] * this.getY();
	    this.localCoords = coords;
	}
	

	@Override
	public int hashCode() {
	    int result;
	    long temp;
	    result = volume != null ? volume.hashCode() : 0;
	    result = 31 * result + (rigidMove ? 1 : 0);
	    temp = Double.doubleToLongBits(minDistance);
	    result = 31 * result + (int) (temp ^ (temp >>> 32));
	    result = 31 * result + Arrays.deepHashCode(agreement);
	    return result;
	}


	@Override
	protected Object clone() {
	    Robot r = new Robot() {
	        @Override
	        public SnapShot look() {
	            return null;
	        }

	        @Override
	        public Destination compute(SnapShot snap) {
	            return null;
	        }

	        @Override
	        public void move(Destination a) {

	        }
	    };
	    r.setLocation(this.getX(), this.getY());

	    return r;
	}
}

class FullVisRobot extends Robot{
	
	    
       	public FullVisRobot()
       	{
       		
       	}
		public FullVisRobot(Point2D currentLocation)
		{
			   this.sensingRange = Double.POSITIVE_INFINITY; 
			  //it is important to  disable wireless for robot
		       this.disableWireless();
		       this.color=Color.red;
		       this.size=10;
		       this.setLocation(currentLocation.getX(),currentLocation.getY());
		}
	
	
	public void move(Destination dest){
		this.dest = (Destination2D)dest;
		setDirection(((Destination2D)dest).dest);
		move(this.distance(this.dest));
	}


	public SnapShot look(){
		snap.getSnapShot(this);
		return snap;
	}

	public Destination compute(SnapShot snap){
		Destination2D dest = new Destination2D();
		return dest;
	}
}


class LimitedVisRobot extends Robot {

    public LimitedVisRobot(Double sensingRange, Point2D currentLocation) {
        this.sensingRange = sensingRange;
        this.disableWireless();
        this.setLocation(currentLocation.getX(), currentLocation.getY());
    }

    public void move(Destination dest) {
        this.dest = (Destination2D) dest;
        this.setDirection(((Destination2D) dest).dest);
        move(this.distance(this.dest));
    }

    public SnapShot look() {
    	snap.getSnapShot(this);
        return snap;
    }

    public Destination compute(SnapShot snap) {
        Destination dest = new Destination2D();
        return dest;
    }
}

class ObstrucVisRobot extends Robot {

    //Only the center of robot can sense its neighbors rather than the whole volue
    Boolean centerSensing = false;

    public ObstrucVisRobot(Point2D currentLocation, Double sensingRange, Volume volume, boolean rigidMove) {
        this.rigidMove = rigidMove;
        this.volume = volume;
        if (volume != null) {
            this.setSize((int) volume.getSquare());
        }
        this.sensingRange = sensingRange;
        this.disableWireless();
        this.setLocation(currentLocation.getX(), currentLocation.getY());
    }

    public void move(Destination dest) {
    	System.out.println(dest);
        this.dest = dest;
        this.setDirection(((Destination2D) dest).dest);
        // Temporarily for testing
        double distance = this.distance(dest);
        move(distance(dest));
        System.out.println("Robot " + this.getID()
                + " has moved distance of " + distance);
    }

    public SnapShot look() {
        SnapShot snap = new SnapShot();
        for(Robot r: this.getSensedRobotsNotObstructed())
        	snap.visRobots.add(r);
        this.snap =snap;
        return snap;
    }

    public Destination compute(SnapShot snap) {

        Destination dest = new Destination2D();
        return dest;
    }

    /**
     * Returns a list containing every Robot located within the sensing range
     * and not obstruced by other Robot
     *
     * @return A list containing all Robot within sensing range
     */
    public ArrayList<Robot> getSensedRobotsNotObstructed() {
        ArrayList<Robot> sensedNodes = new ArrayList<Robot>();

        for (Robot sensedRobot : this.getSensedRobots()) {
            if (this.isObstructed(sensedRobot)) {
                continue;
            }
            sensedNodes.add(sensedRobot);
        }
        return sensedNodes;
    }

    /**
     * Determine the node has been obstructed by other nodes
     * so that the node cannot be sensed by this node
     *
     * @param sensedRobot
     * @return a boolean value
     */
    private boolean isObstructed(Robot sensedRobot) {
        double distance1 = this.distance(sensedRobot);
        for (Robot robot : this.getSensedRobots()) {
            double distance2 = this.distance(robot);
            if (distance1 > distance2) {
                if ((this.volume == null) ||
                        (this.volume.equalsTo(robot.volume) &&
                                sensedRobot.volume.equalsTo(robot.volume))) {
                    double distance3 = sensedRobot.distance(robot);
                    if (areAligned(sensedRobot, robot) && distance3 < distance1) {
                        return true;
                    }
                } else if (!centerSensing) {
                    if (this.volume.isBiggerThan(robot.volume) &&
                            sensedRobot.volume.isBiggerThan(robot.volume)) {
                        return false;
                    } else {
                        ArrayList<Line2D> tLines = this.volume.commonTanLines(robot.volume);
                        if (sensedRobot.volume.isInLinesArea(tLines, robot.volume)) {
                            return true;
                        }
                        return false;
                    }
                } else {
                    //Get the tangent lines from center to the robot volume
                    ArrayList<Line2D> tLines = this.volume.pointTanLines(this.volume.getCenter(), robot.volume);
                    if (sensedRobot.volume.isInLinesArea(tLines, robot.volume)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    /**
     * Judge whether this node and the other two Robots are aligned
     *
     * @param robot1
     * @param robot2
     * @return a boolean value
     */
    private boolean areAligned(Robot robot1, Robot robot2) {
        //get x and y of this robot1
        double x1 = this.coords.getX();
        double y1 = this.coords.getY();
        //get x and y of sensedRobot
        double x2 = robot1.coords.getX();
        double y2 = robot1.coords.getY();
        //get x and y of
        double x3 = robot2.coords.getX();
        double y3 = robot2.coords.getY();

        if ((x3 - x1 != 0) && (x2 - x1 != 0)) {
            double slope1 = (y3 - y1) / (x3 - x1);
            double slope2 = (y2 - y1) / (x2 - x1);
            if (slope1 == slope2) {
                return true;
            }
            return false;
        } else if ((x3 - x1 == 0) && (x2 - x1 == 0)) {
            return true;
        } else {
            return false;
        }
    }

    public void setRigidMove(boolean rigidMove) {
        this.rigidMove = rigidMove;
    }
}

